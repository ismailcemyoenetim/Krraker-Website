<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Krraker Lab - Infinite Canvas</title>
    <link rel="stylesheet" href="../styles.css"> <!-- Link to the main stylesheet -->
    <style>
        /* Specific styles for canvas page */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars on the body */
            background-color: var(--primary-bg);
            font-family: "Space Mono", monospace; /* Ensure font consistency */
            color: var(--text-color);
        }
        #drawingCanvas {
            display: block;
            background-color: #000000; /* Change background to black */
            /* Cursor will be set by JS based on selected tool */
        }

        /* Toolbar Styling - Updated for Vertical Layout */
        .toolbar {
            position: fixed;
            top: 50%; /* Center vertically */
            left: 20px;
            transform: translateY(-50%); /* Fine-tune vertical centering */
            background: rgba(30, 30, 30, 0.9); /* Darker background */
            backdrop-filter: blur(5px);
            border: 1px solid rgba(80, 80, 80, 0.5); /* More prominent border */
            border-radius: 7px;
            padding: 10px 5px; /* Adjust padding */
            z-index: 1001;
            display: flex;
            flex-direction: column; /* Stack tools vertically */
            align-items: center; /* Center icons horizontally */
            gap: 8px; /* Space between tools */
            width: 50px; /* Fixed width */
        }
        .toolbar button {
            background: none; /* Transparent background */
            border: 1px solid transparent; /* Transparent border */
            color: rgba(255, 255, 255, 0.6);
            padding: 8px; /* Adjust padding for icons */
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: "Space Mono", monospace;
            font-size: 18px; /* Larger for icon placeholders */
            width: 36px; /* Fixed width for button */
            height: 36px; /* Fixed height for button */
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1;
        }
        .toolbar button:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            border-color: rgba(255, 255, 255, 0.2);
        }
        .toolbar button.active {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-color);
            border-color: rgba(255, 255, 255, 0.4);
        }

        /* Separator */
        .toolbar-separator {
            width: 80%;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.1);
            margin: 5px 0;
        }

        /* Color Picker Placeholder Styling */
        .color-picker-container {
            position: relative;
            width: 36px;
            height: 50px; /* Height for two overlapping squares */
            margin-top: 5px;
        }
        .color-swatch {
            position: absolute;
            width: 28px;
            height: 28px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 3px;
            cursor: pointer;
        }
        .color-swatch.foreground {
            top: 0;
            left: 0;
            background-color: #ffffff; /* Default foreground: white */
            z-index: 2;
        }
        .color-swatch.background {
            bottom: 0;
            right: 0;
            background-color: #000000; /* Default background: black */
            z-index: 1;
        }
        /* TODO: Add click handlers for color pickers */

        /* Invert Button Styling (Adjust position) */
        /* REMOVED - Should inherit from styles.css */
        /* .invert-button { ... } */

        /* Zoom Indicator Styling */
        #zoomIndicator {
            /* Style remains the same, position might need adjustment if overlaps */
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 7px;
            padding: 8px 15px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            z-index: 1001;
        }

        /* Debug info styling */
        #debugInfo {
            /* Style remains the same */
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            z-index: 1000;
            pointer-events: none;
        }

        /* Upload Button Styling */
        .upload-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 7px;
            padding: 10px 20px;
            color: rgba(255, 255, 255, 0.6);
            font-family: "Space Mono", monospace;
            font-size: 14px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s ease;
        }
        .upload-button:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            border-color: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <!-- Back to Home Button -->
    <a href="/" class="back-button" style="position: fixed; top: 60px; left: 20px; z-index: 1001;">‚Üê Back</a>
    <!-- Invert Button -->
    <button class="invert-button" style="position: fixed; top: 20px; left: 20px; z-index: 1001;">
        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
    </button>

    <!-- Vertical Toolbar -->
    <div class="toolbar">
        <!-- Using text placeholders for icons initially -->
        <button id="toolSelect" title="Select">&#x27A4;</button> <!-- Placeholder Arrow -->
        <button id="toolBrush" title="Brush">&#x2710;</button> <!-- Placeholder Brush/Pencil -->
        <button id="toolEraser" title="Eraser">&#x232B;</button> <!-- Eraser -->
        <button id="toolText" title="Text">T</button>
        <button id="toolEyedropper" title="Eyedropper">&#x2694;</button> <!-- Placeholder Syringe/Pipette -->
        
        <div class="toolbar-separator"></div>
        
        <button id="toolPan" class="active" title="Pan">&#x270B;</button> <!-- Hand -->
        <button id="toolZoom" title="Zoom (use Wheel)">Z</button> <!-- Placeholder, actual zoom is wheel -->
        
        <div class="toolbar-separator"></div>
        
        <!-- Color Picker Placeholders -->
        <div class="color-picker-container">
            <div class="color-swatch background" title="Background Color"></div>
            <div class="color-swatch foreground" title="Foreground Color"></div>
            <!-- Add swap color button later? -->
        </div>
        <!-- Add other tool buttons here -->
    </div>

    <!-- Zoom Indicator -->
    <div id="zoomIndicator">Zoom: 1.00x</div>

    <!-- Debug Info Container -->
    <div id="debugInfo">
        Offset: 0, 0<br>
        Scale: 1.00x
    </div>

    <!-- Image Upload Elements -->
    <input type="file" id="imageUploadInput" accept="image/*" style="display: none;">
    <button id="uploadImageButton" class="upload-button">Upload Image</button>

    <canvas id="drawingCanvas"></canvas>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.7/firebase-app.js";
      import { getFirestore, collection, onSnapshot, addDoc, updateDoc, deleteDoc, doc, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore.js";
      import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.6.7/firebase-auth.js";

      const firebaseConfig = {
        apiKey: "AIzaSyC5KQx0U5dl7e6hMcjhFZqPQiTPh_Qvs9s",
        authDomain: "krraker-db.firebaseapp.com",
        projectId: "krraker-db",
        storageBucket: "krraker-db.firebasestorage.app",
        messagingSenderId: "658555321674",
        appId: "1:658555321674:web:6634ab758b652e350695b3",
        measurementId: "G-58165Z0CB3"
      };

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);
      const auth = getAuth(app);

      console.log('Firebase Client SDK Initialized');

      onAuthStateChanged(auth, (user) => {
        if (user) {
          console.log('User signed in anonymously with UID:', user.uid);
          currentUserUid = user.uid;
          const elementsCollectionRef = collection(db, 'canvasElements');
          
          let isInitialLoad = true;
          
          onSnapshot(elementsCollectionRef, snapshot => {
            console.log('Firestore snapshot received');
            const changes = snapshot.docChanges();
            
            if (isInitialLoad) {
                console.log("Initial data load:");
                drawingData = [];
                snapshot.docs.forEach(doc => {
                    drawingData.push({ id: doc.id, ...doc.data() });
                });
                console.log(`Loaded ${drawingData.length} initial elements.`);
                isInitialLoad = false;
                console.log(`[${Date.now()}] Listener: Initial load complete. drawingData length: ${drawingData.length}`);
            } else {
                console.log("Processing subsequent changes:");
                changes.forEach(change => {
                  const docData = change.doc.data();
                  const docId = change.doc.id;
                  
                  if (change.type === "added") {
                    console.log("New element: ", docId);
                    if (!drawingData.some(item => item.id === docId)) {
                        drawingData.push({ id: docId, ...docData });
                    }
                  }
                  if (change.type === "modified") {
                    console.log("Modified element: ", docId);
                    const index = drawingData.findIndex(item => item.id === docId);
                    if (index > -1) {
                      drawingData[index] = { id: docId, ...docData };
                    }
                  }
                  if (change.type === "removed") {
                    console.log("Removed element: ", docId);
                    drawingData = drawingData.filter(item => item.id !== docId);
                  }
                });
                console.log(`[${Date.now()}] Listener: Changes processed. drawingData length: ${drawingData.length}`);
            }

            console.log(`[${Date.now()}] Listener: Calling redrawCanvas. drawingData length: ${drawingData.length}`);
            redrawCanvas();
          }, error => {
            console.error("Error listening to Firestore:", error);
          });
        } else {
          console.log('User is signed out. Signing in anonymously...');
          signInAnonymously(auth).catch(error => {
            console.error("Error signing in anonymously:", error);
          });
        }
      });

      const canvas = document.getElementById('drawingCanvas');
      const ctx = canvas.getContext('2d');
      const zoomIndicator = document.getElementById('zoomIndicator');
      const debugInfo = document.getElementById('debugInfo');
      const invertButton = document.querySelector('.invert-button');
      const toolbar = document.querySelector('.toolbar');
      const toolPanButton = document.getElementById('toolPan');
      const toolBrushButton = document.getElementById('toolBrush');
      const toolSelectButton = document.getElementById('toolSelect');
      const toolTextButton = document.getElementById('toolText');
      const toolEyedropperButton = document.getElementById('toolEyedropper');
      const toolZoomButton = document.getElementById('toolZoom');
      const toolEraserButton = document.getElementById('toolEraser');
      const uploadImageButton = document.getElementById('uploadImageButton');
      const imageUploadInput = document.getElementById('imageUploadInput');

      let currentUserUid = null;
      let currentTool = 'pan';
      let scale = 1;
      const minScale = 0.1;
      const maxScale = 10;
      const scaleSensitivity = 0.001;

      let offsetX = 0;
      let offsetY = 0;
      let isPanning = false;
      let isDrawing = false;
      let isPlacingImage = false;
      let pendingImage = null;
      let selectedItem = null;
      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let isRotating = false;
      const handleSize = 8;
      const rotationHandleOffset = 20;
      let lastPanX = 0;
      let lastPanY = 0;

      let drawingData = [];
      let currentStroke = null; 
      let currentBrushColor = '#ffffff';
      let currentBrushSize = 2;
      let currentEraserSize = 10;

      const gridSpacing = 25;
      const gridDotSize = 1;
      const gridDotColor = 'rgba(210, 210, 210, 1.5)';

      function screenToWorld(screenX, screenY) {
          return {
              x: (screenX - offsetX) / scale,
              y: (screenY - offsetY) / scale
          };
      }

      function distance(p1, p2) {
          return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      }

      function screenToItemLocal(screenPoint, item) {
          if (!item) return null;
          let worldX = (screenPoint.x - offsetX) / scale;
          let worldY = (screenPoint.y - offsetY) / scale;
          worldX -= item.x;
          worldY -= item.y;
          const cos = Math.cos(-item.angle || 0);
          const sin = Math.sin(-item.angle || 0);
          const localX = worldX * cos - worldY * sin;
          const localY = worldX * sin + worldY * cos;
          return { x: localX, y: localY };
      }

      function getHitRotationHandle(screenPoint, item) {
          if (!item || item.type !== 'image') return null;
          const localPoint = screenToItemLocal(screenPoint, item);
          if (!localPoint) return null;

          const halfWidth = (item.width / 2) || (item.naturalWidth / 2);
          const halfHeight = (item.height / 2) || (item.naturalHeight / 2);
          const handleDist = handleSize / 2 / scale;
          const offsetDist = rotationHandleOffset / scale;

          const handlePositions = [
              { x: halfWidth + offsetDist, y: -halfHeight - offsetDist, corner: 'topRight' },
              { x: -halfWidth - offsetDist, y: -halfHeight - offsetDist, corner: 'topLeft' },
              { x: halfWidth + offsetDist, y: halfHeight + offsetDist, corner: 'bottomRight' },
              { x: -halfWidth - offsetDist, y: halfHeight + offsetDist, corner: 'bottomLeft' }
          ];

          for (const handle of handlePositions) {
              if (Math.abs(localPoint.x - handle.x) <= handleDist && Math.abs(localPoint.y - handle.y) <= handleDist) {
                  return handle.corner;
              }
          }
          return null;
      }

      function isPointInImage(point, imageItem) {
          if (!imageItem || imageItem.type !== 'image') return false;
          const halfWidth = (imageItem.width / 2) || (imageItem.naturalWidth / 2);
          const halfHeight = (imageItem.height / 2) || (imageItem.naturalHeight / 2);
          return (
              point.x >= imageItem.x - halfWidth &&
              point.x <= imageItem.x + halfWidth &&
              point.y >= imageItem.y - halfHeight &&
              point.y <= imageItem.y + halfHeight
          );
      }

      function redrawCanvas() {
          const timestamp = Date.now();
          console.log(
              `[${timestamp}] redrawCanvas START.\n                 drawingData length: ${drawingData.length}\n                 drawingData IDs: ${drawingData.map(item => item?.id || 'null-id').join(', ') || 'empty'}\n                 currentStroke points: ${currentStroke ? currentStroke.points.length : 'null'}`
          );

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const topLeft = screenToWorld(0, 0);
          const bottomRight = screenToWorld(canvas.width, canvas.height);
          const viewWidth = bottomRight.x - topLeft.x;
          const viewHeight = bottomRight.y - topLeft.y;

          ctx.save();
          ctx.translate(offsetX, offsetY);
          ctx.scale(scale, scale);

          ctx.fillStyle = gridDotColor;
          const startX = Math.floor(topLeft.x / gridSpacing) * gridSpacing;
          const startY = Math.floor(topLeft.y / gridSpacing) * gridSpacing;
          const endX = bottomRight.x;
          const endY = bottomRight.y;

          if ((gridDotSize * scale) >= 0.5) { 
              for (let x = startX; x < endX; x += gridSpacing) {
                  for (let y = startY; y < endY; y += gridSpacing) {
                      const scaledDotSize = gridDotSize / scale;
                      ctx.fillRect(x - scaledDotSize / 2, y - scaledDotSize / 2, scaledDotSize, scaledDotSize);
                  }
              }
          }
          
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          drawingData.forEach((item, index) => {
              if (!item || !item.id) {
                  console.warn(`[${timestamp}] Skipping invalid item at index ${index}:`, item);
                  return;
              }

              console.log(`[${timestamp}] Drawing item ID: ${item.id}, Type: ${item.type}`);

              if (item.type === 'stroke' && item.points && item.points.length > 1) {
                  ctx.strokeStyle = item.color;
                  ctx.lineWidth = item.lineWidth;
                  ctx.beginPath();
                  ctx.moveTo(item.points[0].x, item.points[0].y);
                  for (let i = 1; i < item.points.length; i++) {
                      ctx.lineTo(item.points[i].x, item.points[i].y);
                  }
                  ctx.stroke();
              } else if (item.type === 'image' && item.src) {
                  const img = new Image();
                  img.onload = () => {
                      const width = item.width || img.naturalWidth;
                      const height = item.height || img.naturalHeight;
                      
                      ctx.save();
                      ctx.translate(item.x, item.y);
                      ctx.rotate(item.angle || 0);
                      
                      ctx.drawImage(img, -width / 2, -height / 2, width, height);
                      
                      if (selectedItem === item) {
                          drawSelectionControls(ctx, width, height);
                      }
                      
                      ctx.restore();
                  };
                  img.onerror = () => {
                      console.error("Error loading image src for drawing:", item.src.substring(0, 50) + "...");
                  };
                  img.src = item.src;
              }
          });

          if (selectedItem && selectedItem.type === 'image') {
              const halfWidth = (selectedItem.width / 2) || (selectedItem.naturalWidth / 2);
              const halfHeight = (selectedItem.height / 2) || (selectedItem.naturalHeight / 2);
              ctx.strokeStyle = 'rgba(0, 150, 255, 0.8)';
              ctx.lineWidth = 2 / scale;
              ctx.setLineDash([6 / scale, 3 / scale]);
              ctx.strokeRect(
                  selectedItem.x - halfWidth, 
                  selectedItem.y - halfHeight, 
                  halfWidth * 2, 
                  halfHeight * 2
              );
              ctx.setLineDash([]);
          }

          if (currentStroke && currentStroke.tool === 'brush' && currentStroke.points && currentStroke.points.length > 1) {
              console.log(`[${timestamp}] Drawing current stroke (${currentStroke.points.length} points)`);
              ctx.strokeStyle = currentStroke.color;
              ctx.lineWidth = currentStroke.lineWidth;
              ctx.beginPath();
              ctx.moveTo(currentStroke.points[0].x, currentStroke.points[0].y);
              for (let i = 1; i < currentStroke.points.length; i++) {
                  ctx.lineTo(currentStroke.points[i].x, currentStroke.points[i].y);
              }
              ctx.stroke();
          }
          ctx.restore();
          zoomIndicator.textContent = `Zoom: ${scale.toFixed(2)}x`;
          debugInfo.innerHTML = `Offset: ${offsetX.toFixed(0)}, ${offsetY.toFixed(0)}<br>Scale: ${scale.toFixed(2)}x`;
          console.log(`[${timestamp}] redrawCanvas END.`);
      }

      function drawSelectionControls(context, width, height) {
          const halfWidth = width / 2;
          const halfHeight = height / 2;
          const handleScreenSize = handleSize / scale;
          const rotOffsetScreen = rotationHandleOffset / scale;

          context.strokeStyle = 'rgba(0, 150, 255, 0.8)';
          context.lineWidth = 2 / scale;
          
          context.setLineDash([6 / scale, 3 / scale]);
          context.strokeRect(-halfWidth, -halfHeight, width, height);
          context.setLineDash([]);

          context.fillStyle = 'rgba(0, 150, 255, 0.8)';
          const rotationHandlePositions = [
              { x: halfWidth + rotOffsetScreen, y: -halfHeight - rotOffsetScreen },
              { x: -halfWidth - rotOffsetScreen, y: -halfHeight - rotOffsetScreen },
              { x: halfWidth + rotOffsetScreen, y: halfHeight + rotOffsetScreen },
              { x: -halfWidth - rotOffsetScreen, y: halfHeight + rotOffsetScreen }
          ];
          rotationHandlePositions.forEach(pos => {
              context.beginPath();
              context.arc(pos.x, pos.y, handleScreenSize / 2, 0, Math.PI * 2);
              context.fill();
          });
      }

      function setActiveTool(tool) {
          currentTool = tool;
          console.log("Tool changed to:", currentTool);
          
          toolbar.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
          const activeButton = document.getElementById(`tool${tool.charAt(0).toUpperCase() + tool.slice(1)}`);
          if (activeButton) {
               activeButton.classList.add('active');
          } else {
              console.warn("Button not found for tool:", tool);
          }
          
          switch (tool) {
              case 'pan':
                  canvas.style.cursor = 'grab';
                  break;
              case 'brush':
                  canvas.style.cursor = 'crosshair'; 
                  break;
              case 'eraser':
                  canvas.style.cursor = 'cell';
                  break;
              case 'select':
                  canvas.style.cursor = 'default';
                  break;
              case 'text':
                  canvas.style.cursor = 'text';
                  break;
               case 'eyedropper':
                  canvas.style.cursor = 'copy';
                  break;
              case 'zoom':
                   canvas.style.cursor = 'zoom-in';
                   break;
              case 'placeImage':
                  canvas.style.cursor = 'copy';
                  break;
              default:
                  canvas.style.cursor = 'default';
          }
      }
      
      toolPanButton.addEventListener('click', () => setActiveTool('pan'));
      toolBrushButton.addEventListener('click', () => setActiveTool('brush'));
      toolSelectButton.addEventListener('click', () => setActiveTool('select'));
      toolTextButton.addEventListener('click', () => setActiveTool('text'));
      toolEyedropperButton.addEventListener('click', () => setActiveTool('eyedropper'));
      toolZoomButton.addEventListener('click', () => setActiveTool('zoom'));
      toolEraserButton.addEventListener('click', () => setActiveTool('eraser'));

      uploadImageButton.addEventListener('click', () => {
          imageUploadInput.click();
      });

      imageUploadInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
              const reader = new FileReader();
              reader.onload = (event) => {
                  pendingImage = new Image();
                  pendingImage.onload = () => {
                      console.log('Image loaded, ready to place:', pendingImage.width, 'x', pendingImage.height);
                      isPlacingImage = true;
                      setActiveTool('placeImage');
                  };
                  pendingImage.onerror = () => {
                      console.error("Error loading selected image file.");
                      pendingImage = null;
                      isPlacingImage = false;
                      setActiveTool('pan');
                  };
                  pendingImage.src = event.target.result;
              };
              reader.onerror = () => {
                  console.error("Error reading file.");
                   pendingImage = null;
                   isPlacingImage = false;
                   setActiveTool('pan');
              };
              reader.readAsDataURL(file);
          }
          e.target.value = null; 
      });

      invertButton.addEventListener('click', function() {
          // Add rotation animation to button
          this.classList.add('theme-switching');
          
          // Toggle inverted class on body
          document.body.classList.toggle('inverted');
          
          // Save preference
          const isInverted = document.body.classList.contains('inverted');
          localStorage.setItem('colorInverted', isInverted);
          
          // Remove animation class after transition completes
          setTimeout(() => {
              this.classList.remove('theme-switching');
          }, 500);
      });
      if (localStorage.getItem('colorInverted') === 'true') {
           document.body.classList.add('inverted');
      }

      function resizeCanvas() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          redrawCanvas();
      }

      canvas.addEventListener('mousedown', (e) => {
          const startPos = screenToWorld(e.clientX, e.clientY);
          const startScreenPos = { x: e.clientX, y: e.clientY };
          console.log(`Mousedown - Tool: ${currentTool}`);
          isDragging = false;
          isRotating = false;
          let rotationHandleHit = null;

          if (isPlacingImage && pendingImage) {
              console.log("Placing image at", startPos);
              const imgData = {
                  type: 'image',
                  src: pendingImage.src,
                  x: startPos.x,
                  y: startPos.y,
                  naturalWidth: pendingImage.naturalWidth,
                  naturalHeight: pendingImage.naturalHeight,
                  width: pendingImage.naturalWidth,
                  height: pendingImage.naturalHeight 
              };
              drawingData.push(imgData);
              redrawCanvas();
              
              isPlacingImage = false;
              pendingImage = null;
              setActiveTool('pan');

          } else if (currentTool === 'select') {
               selectedItem = null;
               for (let i = drawingData.length - 1; i >= 0; i--) {
                    const item = drawingData[i];
                    if (item.type === 'image') {
                         rotationHandleHit = getHitRotationHandle(startScreenPos, item);
                         if (rotationHandleHit) {
                             console.log("Hit rotation handle:", rotationHandleHit);
                             selectedItem = item;
                             isRotating = true;
                             break;
                         }
                    }
               }

               if (!isRotating) {
                   for (let i = drawingData.length - 1; i >= 0; i--) {
                       const item = drawingData[i];
                       if (item.type === 'image' && isPointInImage(startPos, item)) {
                           selectedItem = item;
                           isDragging = true;
                           dragOffsetX = startPos.x - selectedItem.x;
                           dragOffsetY = startPos.y - selectedItem.y;
                           console.log('Selected Image:', selectedItem);
                           break; 
                       }
                   }
               }
               
               redrawCanvas();
               
               if (isRotating) {
                   canvas.style.cursor = 'crosshair';
               } else if (isDragging) {
                   canvas.style.cursor = 'move';
               } else {
                  canvas.style.cursor = 'default';
               }

          } else if (currentTool === 'pan') {
              console.log('Starting Pan');
              isPanning = true;
              lastPanX = e.clientX;
              lastPanY = e.clientY;
              canvas.style.cursor = 'grabbing';
          } else if (currentTool === 'brush') {
              isDrawing = true;
              currentStroke = {
                  tool: 'brush',
                  color: currentBrushColor,
                  lineWidth: currentBrushSize / scale,
                  points: [startPos]
              };
              console.log('Start Drawing Stroke:', currentStroke);
          } else if (currentTool === 'eraser') {
              isDrawing = true;
              currentStroke = {
                  tool: 'eraser',
                  lineWidth: currentEraserSize / scale,
                  points: [startPos]
              };
              console.log('Start Erasing Path:', currentStroke);
          } else if (currentTool === 'eyedropper') {
              console.log('Eyedropper click at:', startPos);
          } else {
               console.log(`${currentTool} mousedown at:`, startPos);
          }
      });

      canvas.addEventListener('mousemove', (e) => {
           const currentPos = screenToWorld(e.clientX, e.clientY);
           const currentScreenPos = { x: e.clientX, y: e.clientY };

           if (isRotating && selectedItem && currentTool === 'select') {
               const center = { x: selectedItem.x, y: selectedItem.y };
               const currentAngle = Math.atan2(currentPos.y - center.y, currentPos.x - center.x);
               const startWorldPos = screenToWorld(startScreenPos.x, startScreenPos.y);
               const startAngle = Math.atan2(startWorldPos.y - center.y, startWorldPos.x - center.x);
               
               selectedItem.angle = (selectedItem.angle || 0) + (currentAngle - startAngle);
               redrawCanvas();
           } else if (isDragging && selectedItem && currentTool === 'select') {
               selectedItem.x = currentPos.x - dragOffsetX;
               selectedItem.y = currentPos.y - dragOffsetY;
               redrawCanvas();
           
           } else if (isPanning && currentTool === 'pan') {
               const dx = e.clientX - lastPanX;
               const dy = e.clientY - lastPanY;
               offsetX += dx;
               offsetY += dy;
               lastPanX = e.clientX;
               lastPanY = e.clientY;
               redrawCanvas();
          } else if (isDrawing && (currentTool === 'brush' || currentTool === 'eraser')) {
              if (currentStroke) {
                  currentStroke.points.push(currentPos);
                  redrawCanvas(); 
              }
          }
      });

      canvas.addEventListener('mouseup', (e) => {
           console.log(`Mouseup - Tool: ${currentTool}`);
           if (isPlacingImage) return;

           if (isRotating && selectedItem && currentTool === 'select') {
               console.log('Finished rotating', selectedItem);
               isRotating = false;
               redrawCanvas();
               canvas.style.cursor = 'default';
           }

           if (isDragging && selectedItem && currentTool === 'select') {
               console.log('Finished dragging', selectedItem);
               isDragging = false;
               redrawCanvas();
               canvas.style.cursor = 'default';
           }

           if (isPanning && currentTool === 'pan') {
              console.log('Ending Pan');
              isPanning = false;
              canvas.style.cursor = 'grab';
           } else if (isDrawing && currentTool === 'brush') {
              isDrawing = false;
              canvas.style.cursor = 'crosshair';
              if (currentStroke && currentStroke.points.length > 1) {
                  const strokeData = {
                    type: 'stroke',
                    tool: currentStroke.tool,
                    color: currentStroke.color,
                    lineWidth: currentStroke.lineWidth,
                    points: currentStroke.points,
                    creatorUid: currentUserUid,
                    timestamp: serverTimestamp()
                  };

                  console.log('Saving stroke to Firestore:', strokeData);
                  
                  addDoc(collection(db, 'canvasElements'), strokeData)
                    .then(docRef => {
                      console.log("Stroke saved with ID: ", docRef.id);
                    })
                    .catch(error => {
                      console.error("Error saving stroke: ", error);
                    });
              } else {
                  console.log('Discarding short stroke.');
              }
              currentStroke = null;
           } else if (isDrawing && currentTool === 'eraser') {
              isDrawing = false;
              canvas.style.cursor = 'cell';
              console.log('Finishing Erase Path');
              if (currentStroke && currentStroke.points.length > 0) {
                  const eraserPath = currentStroke.points;
                  const eraserRadius = (currentEraserSize / scale) / 2;
                  let itemsToDelete = [];

                  drawingData.forEach(item => {
                      if (item.type === 'stroke' && item.creatorUid === currentUserUid && item.points) {
                          for (const strokePoint of item.points) {
                              for (const eraserPoint of eraserPath) {
                                  if (distance(strokePoint, eraserPoint) < eraserRadius + (item.lineWidth / 2) && !itemsToDelete.includes(item.id)) {
                                      console.log('Marking item for deletion:', item.id);
                                      itemsToDelete.push(item.id);
                                      break;
                                  }
                              }
                              if (itemsToDelete.includes(item.id)) break;
                          }
                      }
                  });

                  if (itemsToDelete.length > 0) {
                      console.log(`Deleting ${itemsToDelete.length} items from Firestore...`);
                      const batch = writeBatch(db);
                      itemsToDelete.forEach(id => {
                          const docRef = doc(db, 'canvasElements', id);
                          batch.delete(docRef);
                      });
                      batch.commit()
                          .then(() => {
                              console.log('Items successfully deleted from Firestore.');
                          })
                          .catch(error => {
                              console.error("Error deleting items: ", error);
                          });
                  } else {
                       console.log('No items found to erase.');
                  }
              } else {
                  console.log('Discarding short erase path or user not logged in.');
              }
              currentStroke = null;
           }
      });

      canvas.addEventListener('mouseleave', () => {
           if (isPlacingImage) return;

            if (isRotating && selectedItem && currentTool === 'select') {
                console.log('Cancelled rotating (mouse left)');
                isRotating = false;
                redrawCanvas();
                canvas.style.cursor = 'default';
            }

           if (isDragging && selectedItem && currentTool === 'select') {
               console.log('Cancelled dragging (mouse left)');
               isDragging = false;
               redrawCanvas(); 
               canvas.style.cursor = 'default';
           }

           if (isPanning) {
              console.log('Ending Pan (mouse left)');
              isPanning = false;
              if(currentTool === 'pan') canvas.style.cursor = 'grab';
           }
           if (isDrawing) {
               const tool = currentStroke ? currentStroke.tool : null;
               console.log(`Drawing stopped (mouse left), finalizing ${tool} path.`);
               isDrawing = false;
                
               if (tool === 'brush' && currentStroke && currentStroke.points.length > 1) {
                   const strokeData = {
                       type: 'stroke',
                       tool: currentStroke.tool,
                       color: currentStroke.color,
                       lineWidth: currentStroke.lineWidth,
                       points: currentStroke.points,
                       creatorUid: currentUserUid,
                       timestamp: serverTimestamp()
                   };
                   console.log('Saving stroke to Firestore (mouse left):', strokeData);
                   addDoc(collection(db, 'canvasElements'), strokeData)
                     .then(docRef => { console.log("Stroke saved (mouse left) ID: ", docRef.id); })
                     .catch(error => { console.error("Error saving stroke (mouse left): ", error); });

               } else if (tool === 'eraser' && currentStroke && currentStroke.points.length > 0) {
                   const eraserPath = currentStroke.points;
                   const eraserRadius = (currentEraserSize / scale) / 2;
                   let itemsToDelete = [];
                   
                   drawingData.forEach(item => {
                      if (item.type === 'stroke' && item.creatorUid === currentUserUid && item.points) {
                          for (const strokePoint of item.points) {
                              for (const eraserPoint of eraserPath) {
                                  if (distance(strokePoint, eraserPoint) < eraserRadius + (item.lineWidth / 2) && !itemsToDelete.includes(item.id)) {
                                      itemsToDelete.push(item.id);
                                      break;
                                  }
                              }
                              if (itemsToDelete.includes(item.id)) break;
                          }
                      }
                   });
                   
                   if (itemsToDelete.length > 0) {
                       console.log(`Deleting ${itemsToDelete.length} items from Firestore (mouse left)...`);
                       const batch = writeBatch(db);
                       itemsToDelete.forEach(id => {
                           const docRef = doc(db, 'canvasElements', id);
                           batch.delete(docRef);
                       });
                       batch.commit()
                           .then(() => { console.log('Items successfully deleted (mouse left).'); })
                           .catch(error => { console.error("Error deleting items (mouse left): ", error); });
                   }
               } else if (tool) {
                   console.log(`Discarding short ${tool} path (mouse left).`);
               }
               currentStroke = null;
               if(currentTool === 'brush') canvas.style.cursor = 'crosshair';
               else if (currentTool === 'eraser') canvas.style.cursor = 'cell';
          }
      });

      canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const mouseX = e.clientX;
          const mouseY = e.clientY;
          const worldBefore = screenToWorld(mouseX, mouseY);
          const delta = -e.deltaY * scaleSensitivity;
          const newScale = Math.max(minScale, Math.min(maxScale, scale * (1 + delta)));
          offsetX = mouseX - worldBefore.x * newScale;
          offsetY = mouseY - worldBefore.y * newScale;
          scale = newScale;
          redrawCanvas();
      });

      window.addEventListener('resize', resizeCanvas);
      setActiveTool('pan');
      resizeCanvas();

    </script>
</body>
</html>